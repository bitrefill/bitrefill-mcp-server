---
description: When writing React code
globs: 
---
# Modern React Electron Application Coding Style Guide (2024–2025) - Senior Developer Enhanced

This document is non-negotiable. If your code doesn’t follow these guidelines, it will be rejected. We’re not here to coddle—it’s either high performance, bulletproof maintainability, and rock-solid testability, or it’s not acceptable. Derived and integrated from our mandatory `@stack.mdc` standards for Electron, Vite, TypeScript, and React 18.  This version includes extensive examples for clarity.

---

## 1. Core Principles

- **Absolute Type Safety:**
  Every line of code must be written in TypeScript. There is **zero tolerance** for `any`. You must use explicit types or, when necessary, `unknown` followed by strict type narrowing.

  ```typescript
  // BAD: Using 'any' - This will be rejected.
  function fetchData(data: any) {
    // ...
  }

  // GOOD: Explicit type
  interface UserData {
    id: number;
    name: string;
  }

  function fetchData(data: UserData) {
    // ...
  }

  // GOOD: Using 'unknown' with type narrowing
  function processData(data: unknown) {
    if (typeof data === 'string') {
      console.log(data.toUpperCase());
    } else if (typeof data === 'number') {
      console.log(data * 2);
    } else {
      throw new Error("Invalid data type");
    }
  }
  ```

- **Separation of Concerns:**
  Keep a rigid separation between the main process, renderer process, preload scripts, and shared types. No cross-contamination. This is not optional—it is enforced in every code review.

  *   **Main Process (`src/main`):** Handles application lifecycle, native OS interactions, and IPC.
  *   **Renderer Process (`src/renderer`):**  Your React application.  UI only.
  *   **Preload Script (`src/main/preload.ts`):**  A *very* thin bridge between the renderer and main processes.  Exposes *only* what's absolutely necessary.
  *   **Shared (`src/shared`):**  Type definitions *only*.  No logic.

- **Uncompromising Security:**
  Context isolation, sandboxing, and a strong Content Security Policy (CSP) are mandatory. Expose **only** the minimal APIs in your preload scripts.

  ```typescript
  // src/main/preload.ts
  import { contextBridge, ipcRenderer } from 'electron';

  contextBridge.exposeInMainWorld('backend', {
    send: (channel: string, data: unknown) => {
      // Whitelist channels to prevent arbitrary IPC message sending
      const validChannels = ['toMain'];
      if (validChannels.includes(channel)) {
        ipcRenderer.send(channel, data);
      }
    },
    receive: (channel: string, func: (...args: any[]) => void) => {
      const validChannels = ['fromMain'];
      if (validChannels.includes(channel)) {
        // Deliberately strip event as it includes `sender`
        ipcRenderer.on(channel, (event, ...args) => func(...args));
      }
    },
  });
  ```

- **Modular Architecture:**
  Each feature must live in its own module, with its own IPC handler, tests, and granular component files. A monolithic, spaghetti structure is unacceptable.

- **No Bullshit Policy:**
  No shortcuts, hacks, or design half-measures. If it isn’t built to scale and stand up to scrutiny, it’s not worth the time. Code reviews will be brutal.

---

## 2. Project Structure & File Conventions

Follow the exact directory structure from `@stack.mdc`:

```
├── dist/ (Compiled output, auto-generated)
├── src/
│ ├── main/ (Main Process Code)
│ │ ├── index.ts (Main process entry point)
│ │ ├── preload.ts (Preload script - expose ONLY the necessary APIs)
│ │ └── ipc/
│ │ ├── index.ts (Central IPC handler orchestration)
│ │ └── modules/
│ │ └── serverManagement.ts (Individual IPC modules - Example)
│ ├── renderer/ (React 18 Application)
│ │ ├── index.html (Entry HTML)
│ │ ├── index.tsx (Launcher - must use React 18’s createRoot)
│ │ ├── App.tsx (Root component)
│ │ ├── components/ (Reusable UI Components)
│ │ │ └── ServerButton/
│ │ │ ├── ServerButton.tsx
│ │ │ ├── ServerButton.test.tsx
│ │ │ ├── ServerButton.module.css
│ │ │ └── index.ts
│ │ ├── hooks/ (Custom React hooks)
│ │ ├── services/ (Data fetching and API logic)
│ │ ├── store/ (State management - e.g., Redux Toolkit or Zustand)
│ │ ├── types/ (Renderer-specific TypeScript types)
│ │ └── utils/ (Pure utility functions)
│ └── shared/ (Shared between main and renderer—minimize logic here)
│ └── types.ts (Shared type definitions)
├── package.json
├── tsconfig.json (Base TypeScript configuration; strict mode required)
├── tsconfig-electron.json (For the main process; extends tsconfig.json, "module": "CommonJS")
└── vite.config.ts (Vite configuration for both renderer and main)
```


**Do not deviate** from this structure. Every directory and file has its place.  Example: `serverManagement.ts` handles IPC related to server management, and `ServerButton` is a React component.

---

## 3. TypeScript & Code Quality

- **No `any` Allowed:**
  Every variable, function, and component must be typed explicitly. Weak typing isn’t permitted.  (See examples in Section 1).

- **Strict Configuration:**
  Enable `strictNullChecks`, `noImplicitAny`, and all other strict flags in `tsconfig.json`. No shortcuts here.

  ```json
  // tsconfig.json
  {
    "compilerOptions": {
      "strict": true,
      "noImplicitAny": true,
      "strictNullChecks": true,
      // ... other options ...
    }
  }
  ```

- **Modularity in Shared Code:**
  Only type definitions are allowed in `src/shared`. Do not put logic here.

  ```typescript
  // src/shared/types.ts
  export interface Server {
    id: string;
    name: string;
    status: 'online' | 'offline' | 'maintenance';
  }
  ```

---

## 4. React 18 Renderer Conventions

- **Function Components & Hooks Only:**
  There are no class components in this codebase. Use functional components and the latest React hooks.
  _If you’re still using classes, you’re doing it wrong._

  ```typescript
  // GOOD: Functional component with hooks
  import React, { useState, useEffect } from 'react';

  interface Props {
      serverId: string;
  }

  const ServerStatus: React.FC<Props> = ({ serverId }) => {
    const [status, setStatus] = useState<string>('loading');

    useEffect(() => {
      // Fetch server status...
    }, [serverId]);

    return <div>Server Status: {status}</div>;
  };

  export default ServerStatus;
  ```

- **Create Root Correctly:**
  Use `createRoot` from `react-dom/client` for app mounting. This is mandatory for concurrent rendering.

  ```typescript
  // src/renderer/index.tsx
  import React from 'react';
  import { createRoot } from 'react-dom/client';
  import App from './App';

  const container = document.getElementById('root');
  const root = createRoot(container!); // Non-null assertion because we know #root exists
  root.render(<App />);
  ```

- **Component File Structure:**
  - Each React component must reside in its own folder named in PascalCase.
  - Include a `.tsx` file for the component, a `.module.css` for scoped styling, and a `.test.tsx` for tests.
  - **No exceptions.**

  ```
  // src/renderer/components/ServerButton/ServerButton.tsx
  import React from 'react';
  import styles from './ServerButton.module.css';

  interface Props {
    serverName: string;
    onClick: () => void;
  }

  const ServerButton: React.FC<Props> = ({ serverName, onClick }) => {
    return (
      <button className={styles.button} onClick={onClick}>
        {serverName}
      </button>
    );
  };

  export default ServerButton;

  // src/renderer/components/ServerButton/ServerButton.module.css
  .button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    cursor: pointer;
  }

  // src/renderer/components/ServerButton/ServerButton.test.tsx
  import React from 'react';
  import { render, screen, fireEvent } from '@testing-library/react';
  import ServerButton from './ServerButton';

  test('renders server name and handles clicks', () => {
    const handleClick = jest.fn();
    render(<ServerButton serverName="Test Server" onClick={handleClick} />);
    const buttonElement = screen.getByText('Test Server');
    expect(buttonElement).toBeInTheDocument();
    fireEvent.click(buttonElement);
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

    // src/renderer/components/ServerButton/index.ts
    export { default } from './ServerButton';
  ```

- **Performance Optimizations:**
  - Leverage React’s lazy loading and suspense where possible.
  - Ensure components are small, focused, and only do one thing.
  - Extra complexity means extra review.

  ```typescript
    // Example using React.lazy and Suspense
    const LazyLoadedComponent = React.lazy(() => import('./LazyLoadedComponent'));

    function MyComponent() {
      return (
        <div>
          <Suspense fallback={<div>Loading...</div>}>
            <LazyLoadedComponent />
          </Suspense>
        </div>
      );
    }
  ```

---

## 5. Electron & IPC Standards

- **Preload Scripts:**
  - Must expose **only** the minimal necessary APIs to the renderer.
  - Never leak functionality that can compromise security. (See example in Section 1).

- **IPC Communication:**
  - Use `ipcMain` and `ipcRenderer` exclusively.
  - Build a strongly-typed API wrapper to encapsulate IPC calls.
  - Every IPC channel must be clearly defined, and unnecessary channels are forbidden.

  ```typescript
  // src/main/ipc/modules/serverManagement.ts
  import { ipcMain, IpcMainInvokeEvent } from 'electron';
  import { Server } from '../../../shared/types';

  ipcMain.handle('get-servers', async (event: IpcMainInvokeEvent): Promise<Server[]> => {
    // Fetch servers from database or other source...
    const servers: Server[] = [
      { id: '1', name: 'Server 1', status: 'online' },
      { id: '2', name: 'Server 2', status: 'offline' },
    ];
    return servers;
  });

  // src/main/ipc/index.ts
  import './modules/serverManagement'; // Import to register handlers

  // src/renderer/services/api.ts
  import { Server } from '../../shared/types';

  export const api = {
      getServers: (): Promise<Server[]> => window.backend.invoke('get-servers'),
  };

  // src/renderer/components/ServerList.tsx
    import React, { useState, useEffect } from 'react';
    import { api } from '../services/api';
    import { Server } from '../../shared/types';

    const ServerList: React.FC = () => {
      const [servers, setServers] = useState<Server[]>([]);

      useEffect(() => {
        api.getServers().then(setServers);
      }, []);

      return (
        <ul>
          {servers.map((server) => (
            <li key={server.id}>{server.name} - {server.status}</li>
          ))}
        </ul>
      );
    };
  ```

- **Security Measures:**
  - Always enforce `contextIsolation: true` and use sandboxing.
  - Enable a robust Content Security Policy (CSP).
  - **Any deviation is a security risk and will be flagged.**

  ```typescript
  // src/main/index.ts
  import { app, BrowserWindow } from 'electron';

  function createWindow() {
    const win = new BrowserWindow({
      webPreferences: {
        contextIsolation: true, // Mandatory
        sandbox: true,          // Mandatory
        preload: path.join(__dirname, 'preload.js'),
      },
    });

    // ...
  }
  ```

---

## 6. Vite, HMR, and Performance

- **Mandatory Vite HMR:**
  Vite’s Hot Module Replacement (HMR) must be fully enabled and operational.
  _No manual restarts. No excuses._

- **Efficient Bundling:**
  Configure Vite for optimal tree shaking and dead code elimination. React and Electron’s performance hinge on a lean, mean bundle.

- **Hot Reloading in Main Process:**
  Utilize tools like `electron-vite` to ensure that hot reloading isn’t exclusive to the renderer.

---

## 7. Linting, Formatting, and Code Reviews

- **ESLint & Prettier:**
  Enforce consistent code style with the provided ESLint configuration and Prettier rules.
  _There is no freedom to deviate._

  ```json
  // .eslintrc.json (example - use a comprehensive config)
  {
    "extends": [
      "eslint:recommended",
      "plugin:react/recommended",
      "plugin:@typescript-eslint/recommended"
    ],
    "rules": {
      // ... your specific rules ...
    }
  }
  ```

- **Commit Standards:**
  Every commit must pass linting, build, and test steps. No code bypassing these steps will be accepted.

- **Brutal Code Reviews:**
  Code reviews are rigorous. If you’re not following the guidelines, expect detailed and uncompromising feedback.

---

## 8. Testing and Quality Assurance

- **Component Tests:**
  Every component must have accompanying tests (`.test.tsx`).
  _We do not accept untested UI components._ (See example in Section 4).

- **Unit and Integration Testing:**
  Every new feature must include comprehensive unit tests.
  Consider end-to-end testing (e.g., with Playwright) for critical workflows.

- **Test-Driven Development (TDD):**
  Adopt TDD practices wherever possible.
  If your code isn’t covered by tests, it isn’t production-ready.

---

## 9. Final Word

Modern React Electron apps demand discipline. This guide is the law of the land for development—no compromises. If you want to contribute, your code must be fast, secure, maintainable, and bulletproof in every way.

**Follow these rules to the letter**. Non-adherence is not a suggestion—it’s a mandate.

*Integrated with our stack guidelines (`@stack.mdc`) to ensure a uniform, high-caliber codebase for Electron, Vite, TypeScript, and React 18 development.*