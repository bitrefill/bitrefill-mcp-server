---
description: Instructions about writing MCP services
globs: src/services/**/*.*
---
# MCP Servers Architecture & Integration Specification (Revised)

This document outlines a standardized architecture for implementing and organizing multiple MCP servers in a TypeScript codebase. Each server resides in its own directory and is managed in a uniform way by a central “manager.” The key goals are:

*   Consistent project structure, so new servers can be easily added.
*   Strict modularity, ensuring that each server’s logic, configuration, and tests are isolated.
*   Uniform approach that works for both local (stdio) and SSE-based (HTTP) transports.
*   Ability to add external (npm) MCP servers as easily as internal ones, with minimal changes.

## 1. Directory and File Layout

Below is an example of how to organize multiple MCP servers within the “src/services/mcp” folder:

```
src/
  services/
    mcp/
      ├── manager/
      │    ├── McpServerManager.ts
      │    └── index.ts  // optionally re-exports from McpServerManager
      ├── shared/
      │    └── types.ts      // shared data types or interfaces
      ├── notes/
      │    ├── NotesServer.ts
      │    └── __tests__/
      │         └── NotesServer.test.ts
      ├── timer/
      │    ├── TimerServer.ts
      │    └── __tests__/
      │         └── TimerServer.test.ts
      ├── ... other servers ...
      └── config/
           └── serverRegistry.ts // Renamed from allServers.ts
```

### Key Points:

1.  Each type of MCP server is placed in its own sub-directory, e.g. `notes/` or `timer/`.
2.  Tests are co-located under an `__tests__` directory for easy discoverability.
3.  Shared logic or types used across multiple servers can reside in a `shared/` sub-folder.

This approach ensures that each server is self-contained and that we can add new servers or external imports as new sub-folders or modules.

## 2. Configuration-Driven Initialization

A recommended approach is to have a single source of truth (e.g. an array or dictionary) listing all available MCP servers:

```typescript
// src/services/mcp/config/serverRegistry.ts

import { NotesServer } from "../notes/NotesServer";
import { TimerServer } from "../timer/TimerServer";
import { SomeExternalServer } from "some-external-server-package";
import { McpServerConfig } from "../shared/types";

export const serverRegistry: McpServerConfig[] = [
  {
    id: "notes",
    createInstance: () => new NotesServer(), // factory function
    options: { /* NotesServer-specific options */ }, // Server-specific config
  },
  {
    id: "timer",
    createInstance: () => new TimerServer(),
    options: { /* TimerServer-specific options */ },
  },
  {
    id: "external",
    createInstance: () => new SomeExternalServer({ someOption: true }), // Example with config
    options: { /* SomeExternalServer-specific options */ },
  },
];
```

Here:

1.  `id`: A unique identifier for the server, used by the manager.
2.  `createInstance`: A factory function to instantiate the server class. This can pass config arguments if needed (like transport or environment variables).
3.  `options`:  A placeholder for server-specific configuration options.

You may expand this object definition to store additional info, e.g. “enabled: boolean,” etc.

## 3. MCPServerManager

The manager can read from `serverRegistry` and unify the logic under a single class:

```typescript
// src/services/mcp/manager/McpServerManager.ts

import Logger from "../../utils/logger";
import { serverRegistry } from "../config/serverRegistry";
import { IMcpServerInstance, McpServerConfig, TransportConfig } from "../shared/types"; // Import shared types

export class McpServerManager {
  private servers = new Map<string, IMcpServerInstance>(); // Strongly typed map
  private isRunning = false;

  constructor(private transportConfig: TransportConfig) {}

  public async initialize(): Promise<void> {
    for (const config of serverRegistry) {
      try {
        const serverInstance = config.createInstance();
        this.servers.set(config.id, serverInstance);
        Logger.info(`Initialized MCP server: ${config.id}`, { module: "McpServerManager" });
      } catch (error) {
        Logger.error(`Failed to initialize MCP server: ${config.id}`, error, { module: "McpServerManager" });
        // Consider throwing or handling the error as appropriate
      }
    }
  }

  public async startAll(): Promise<void> {
    if (this.isRunning) {
      Logger.warn("MCP servers are already running", { module: "McpServerManager" });
      return;
    }
    this.isRunning = true;
    const promises = Array.from(this.servers.values()).map(server => server.start(this.transportConfig));
    await Promise.all(promises); // Start all servers concurrently
    Logger.info("All MCP servers started", { module: "McpServerManager" });
  }

  public async stopAll(): Promise<void> {
    if (!this.isRunning) {
      Logger.warn("MCP servers are not running", { module: "McpServerManager" });
      return;
    }
    this.isRunning = false;
    const promises = Array.from(this.servers.values()).map(server => server.stop());
    await Promise.all(promises); // Stop all servers concurrently
    Logger.info("All MCP servers stopped", { module: "McpServerManager" });
  }

  public async toggleServer(id: string, enable: boolean): Promise<void> {
    const server = this.servers.get(id);
    if (!server) {
      Logger.warn(`Server ${id} not found`, { module: "McpServerManager" });
      return;
    }
    try{
        if (enable) {
            await server.start(this.transportConfig);
          } else {
            await server.stop();
          }
    } catch (error){
        Logger.error(`Failed to ${enable ? 'start' : 'stop'} server: ${id}`, error, { module: "McpServerManager" });
    }

  }
}
```

### Explanation:

1.  **initialize:** Reads from `serverRegistry` and instantiates each server.  Uses a `try...catch` block for error handling.
2.  **startAll & stopAll:** Manages the lifecycle for all servers, respecting the manager’s `this.isRunning` to avoid repeated calls. Uses `async/await` and `Promise.all` for asynchronous operation.
3.  **toggleServer:** If the UI or some external process wants to enable/disable a single server (e.g., “notes” or “timer”), that is possible here.  Includes error handling.
4. **Strongly Typed Map:** The `servers` map now uses the `IMcpServerInstance` interface.

With this pattern, each new server you add to `serverRegistry` automatically becomes part of the manager’s lifecycle. You can integrate external servers by simply installing an npm package and referencing them in the list.

## 4. Server Implementation Example

### Directory Structure for “notes/”

```
notes/
  ├── NotesServer.ts
  └── __tests__/
      └── NotesServer.test.ts
```

### Code Example

```typescript
// src/services/mcp/notes/NotesServer.ts

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import { z } from "zod";
import Logger from "../../utils/logger";
import { IMcpServerInstance, TransportConfig } from "../shared/types";

export class NotesServer implements IMcpServerInstance {
  private mcpServer: McpServer | null = null;
  private isEnabled = false;

  public async start(transportConfig: TransportConfig): Promise<void> {
    if (this.isEnabled) {
      Logger.warn("Notes MCP server is already running", { module: "NotesServer" });
      return;
    }

    this.mcpServer = new McpServer({
      transports: [
        transportConfig.type === "stdio"
          ? new StdioServerTransport({})
          : new SSEServerTransport({ path: "/notes" }), // Example SSE path
      ],
      // ... other McpServer options ...
    });

    // Example tool definition with Zod validation
    const myTool = this.mcpServer.addTool({
      name: "myTool",
      description: "My example tool",
      parameters: z.object({
        input: z.string().describe("The input string"),
      }),
      handler: async ({ input }, { context }) => {
        // Tool logic here
        return `Processed: ${input}`;
      },
    });

    this.isEnabled = true;
    Logger.info("Notes MCP server started", { module: "NotesServer" });
  }

  public async stop(): Promise<void> {
    if (!this.isEnabled) {
      Logger.warn("Notes MCP server is not running", { module: "NotesServer" });
      return;
    }
    // ideally do any server cleanup
    this.mcpServer = null; // Example cleanup
    this.isEnabled = false;
    Logger.info("Notes MCP server stopped", { module: "NotesServer" });
  }

  public isRunning(): boolean {
    return this.isEnabled;
  }
}
```

### Tests

```typescript
// src/services/mcp/notes/__tests__/NotesServer.test.ts

import { describe, it, expect } from "vitest";
import { NotesServer } from "../NotesServer";

describe("NotesServer", () => {
  it("should start and stop without errors", async () => { // Use async for testing async methods
    const server = new NotesServer();
    await server.start({ type: "stdio" });
    expect(server.isRunning()).toBe(true);

    await server.stop();
    expect(server.isRunning()).toBe(false);
  });

  // Add more tests here to cover tool definitions, error handling, etc.
});
```

In this example:

*   The server is cleanly self-contained and only references minimal shared items.
*   Tools are added to the MCP server object inside `start()`.
*   We have a short unit test that checks the lifecycle methods. More in-depth tests would check the actual endpoints, the `McpServer` behavior, etc.
*   The `start` and `stop` methods are now asynchronous.
*   An example SSE path (`/notes`) is shown.

## 5. Adding External Servers

With this architecture, adding a new external MCP server is straightforward:

1.  Install the server’s npm package:

    ```bash
    npm install @somecompany/mcp-external
    ```
2.  In `serverRegistry.ts`, add an entry to the array:

    ```typescript
    import { SomeExternalServer } from "@somecompany/mcp-external";

    export const serverRegistry = [
      /* existing servers ... */,
      {
        id: "external",
        createInstance: () => new SomeExternalServer({ someOption: true }), // Example with config
        options: {},
      }
    ];
    ```
3.  The manager automatically picks it up and can start/stop it with the same config approach.

## 6. Shared Types

```typescript
// src/services/mcp/shared/types.ts

export interface IMcpServerInstance {
  start(transportConfig: TransportConfig): Promise<void>;
  stop(): Promise<void>;
  isRunning(): boolean;
}

export type TransportConfig = {
  type: "stdio" | "sse";
  port?: number; // Optional port for SSE
  // Add other transport-related options here
};

export type McpServerConfig = {
    id: string;
    createInstance: () => IMcpServerInstance;
    options?: any; // Server-specific options
}
```
This file defines the key interfaces and types used across the MCP server implementation.

## 7. Integration with Express (Example)
```typescript
// Example of integrating with an existing Express app (assuming you have one)
// This could be in your main process file (e.g., src/main/index.ts)

import express from 'express';
import { McpServerManager } from './services/mcp/manager/McpServerManager';
// ... other imports ...

const app = express();
const port = 3000; // Or get from configuration

// ... other Express middleware and routes ...

const mcpManager = new McpServerManager({ type: 'sse', port });
mcpManager.initialize();
mcpManager.startAll();

// ... potentially other app setup ...

app.listen(port, () => {
  console.log(`Express app listening on port ${port}`);
});

// Make sure to stop the MCP servers when the app closes
process.on('exit', () => {
  mcpManager.stopAll();
});
```
This shows a basic example of how to create the `McpServerManager` and start the servers within an existing Express application. The key is that the `SSEServerTransport` instances within each individual MCP server will handle attaching to the correct paths (e.g., `/notes`, `/timer`).

## 8. Final Security and Maintenance Recommendations

*   **Minimize shared logic**: Put only truly common code in a “shared/” directory (like data types).
*   **Transport Essentials**: For SSE, keep in mind you must have a single Express app providing multiple SSE endpoints. The `SSEServerTransport` instance for each server can be mapped at a unique path.
*   **Consistent Linting**: The entire codebase (manager + each subserver) must follow the same ESLint + Prettier rules for consistent formatting.
*   **Unit Tests**: Each server has its own test suite. The manager can have an integration test verifying it can orchestrate multiple servers at once.
*   **Code Reviews**: Because each server is in a separate folder, it’s easier to review changes in isolation.
*   **CICD**: On each PR, ensure that type-checks, lint checks, and test coverage pass for each server directory.
* **Error Handling**: Implement comprehensive error handling, including `try...catch` blocks, logging, and potentially retry mechanisms.
* **Dependency Injection (Optional)**: For larger projects, consider a DI framework.
* **Zod Validation**: Use Zod (or similar) for all input validation.

---

## Conclusion

By using a configuration-driven approach with a single `serverRegistry` array (or similar structure), each MCP server becomes a standalone module that can be seamlessly integrated, tested, or removed. The manager class ensures consistent lifecycle management. This method is fully compatible with stdio-based or SSE-based servers, and easily extensible to external npm-based MCP servers, all while adhering to the recommended best practices for modular TypeScript/Electron development. The revised architecture incorporates strong typing, asynchronous operations, improved error handling, and clearer configuration, making it more robust and maintainable.