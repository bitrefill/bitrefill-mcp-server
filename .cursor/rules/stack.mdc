---
description: General best practices to apply in the project
globs: **/*.*
---
# Best Practices for Modern Electron Development with Vite and TypeScript

This document outlines best practices for building Electron applications using Vite, TypeScript, and React, focusing on a fast, efficient, and maintainable development workflow.  It synthesizes information from several sources, including best practices from the Electron and Vite communities.

## Core Principles

*   **Speed and Efficiency:** Leverage Vite's fast build times and Hot Module Replacement (HMR) for rapid development.
*   **Type Safety:** Utilize TypeScript for both the main and renderer processes to catch errors early and improve code maintainability.
*   **Modularity:** Structure your application with a clear separation of concerns between the main process, renderer processes, and preload scripts.
*   **Security:** Follow Electron's security recommendations, paying close attention to context isolation and sandboxing.
*   **Maintainability:**  Write clean, well-documented code, and use a consistent project structure.

## Project Setup and Structure

1.  **Project Initialization:**

    *   Use `create-electron` or a well-maintained template like [selfint/electron-vite-ts-react-template](mdc:https:/github.com/selfint/electron-vite-ts-react-template) or [alexwkleung/Electron-ESM-Vite](mdc:https:/github.com/alexwkleung/Electron-ESM-Vite) to scaffold your project.  These templates provide a pre-configured setup with Vite, TypeScript, and often React.  Manually creating a project is also possible, as described in [Build an Electron app using Vite, TypeScript and React](mdc:https:/medium.com/@selfint/build-an-electron-app-using-vite-typescript-and-react-e98f7fc1babd).
    *   Ensure your `package.json` includes the necessary dependencies (Electron, Vite, TypeScript, React, etc.) and scripts for development, building, and packaging.  The `main` field should point to your compiled main process entry point (e.g., `dist/main.js`).

2.  **Directory Structure:**

    A well-defined directory structure is crucial for maintainability.  A recommended structure is:

    ```
    ├── dist/          (Compiled output)
    ├── src/
    │   ├── main/      (Main process code)
    │   │   ├── index.ts     (Main process entry point)
    │   │   ├── api.ts       (IPC handlers)
    │   │   └── preload.ts  (Preload script - bridge to renderer)
    │   ├── renderer/    (Renderer process code - your UI)
    │   │   ├── index.html
    │   │   ├── main.tsx     (Renderer entry point)
    │   │   ├── App.tsx
    │   │   ├── components/
    │   │   └── ...
    │   └── shared/      (Code shared between main and renderer)
    │       └── types.ts   (Shared type definitions)
    ├── public/        (Static assets)
    ├── package.json
    ├── tsconfig.json
    ├── tsconfig-electron.json  (Separate config for main process)
    └── vite.config.ts
    ```

    *   **`src/main`:** Contains the Electron main process code.
    *   **`src/renderer`:** Contains the renderer process code (your React application).
    *   **`src/shared`:**  Houses code that needs to be used by both the main and renderer processes (e.g., type definitions, utility functions).  This avoids duplication and ensures consistency.
    *   **`dist`:** The output directory for compiled code.  Electron loads the application from here.
    *   **`public`:** Static assets that are copied directly to the `dist` folder.
    *   Separate TypeScript configurations (`tsconfig.json` and `tsconfig-electron.json`) are recommended for the renderer and main processes, respectively. The main process configuration should target CommonJS modules (`"module": "CommonJS"` in `tsconfig-electron.json`).

3.  **TypeScript Configuration:**

    *   Use separate `tsconfig.json` files for the main and renderer processes. This allows you to tailor compiler options to each environment.
    *   The main process `tsconfig.json` (often named `tsconfig-electron.json`) should specify `"module": "CommonJS"` and `"outDir": "dist"`.
    *   Extend a base `tsconfig.json` in your specialized configs to avoid duplication.
    *   Define global types for your `backend` object (or whatever you name your inter-process communication bridge) in a `globals.d.ts` file within the `src/electron` directory, as recommended in [Build an Electron app using Vite, TypeScript and React](mdc:https:/medium.com/@selfint/build-an-electron-app-using-vite-typescript-and-react-e98f7fc1babd).

## Development Workflow

1.  **Hot Module Replacement (HMR) and Hot Reloading:**

    *   Vite provides excellent HMR support for the renderer process. Changes to your React components will be reflected instantly in the browser window without a full reload.
    *   For the main process and preload scripts, use a tool like `tsc-watch` (as shown in [Build an Electron app using Vite, TypeScript and React](mdc:https:/medium.com/@selfint/build-an-electron-app-using-vite-typescript-and-react-e98f7fc1babd)) or the built-in hot reloading capabilities of `electron-vite` ([electron-vite.org/guide/](mdc:https:/electron-vite.org/guide)). This automatically restarts the Electron process when changes are detected in the main process or preload scripts.  The `concurrently` package can be used to run Vite and `tsc-watch` simultaneously.
    *   Alternatively, use a custom HMR solution like the one in [alexwkleung/Electron-ESM-Vite](mdc:https:/github.com/alexwkleung/Electron-ESM-Vite), which uses Chokidar to watch for file changes and restart the Electron process.

2.  **Inter-Process Communication (IPC):**

    *   Use the `ipcMain` and `ipcRenderer` modules for communication between the main and renderer processes.
    *   Define a `preload` script (`src/main/preload.ts`) to expose specific functions to the renderer process. This acts as a secure bridge between the renderer's isolated context and the main process's Node.js environment.
    *   Create a strongly-typed API for your IPC using TypeScript interfaces. This improves code clarity and helps prevent errors.  This is often done by creating a `backend` object (or similar) that wraps `ipcRenderer.invoke` calls, as described in [Build an Electron app using Vite, TypeScript and React](mdc:https:/medium.com/@selfint/build-an-electron-app-using-vite-typescript-and-react-e98f7fc1babd).
    *   Avoid exposing the entire `ipcRenderer` object directly to the renderer. Only expose specific, well-defined functions.

3.  **Debugging:**

    *   Use your browser's developer tools to debug the renderer process.
    *   For the main process, you can use a debugger like the one built into VS Code. Attach the debugger to the running Electron process.  `electron-vite` provides guidance on debugging ([electron-vite.org/guide/](mdc:https:/electron-vite.org/guide)).

## Building and Packaging

1.  **Build Process:**

    *   Use `vite build` to build the renderer process.
    *   Use `tsc -p tsconfig-electron.json` to compile the main process code.
    *   Your `package.json` scripts should orchestrate these build steps.

2.  **Packaging:**

    *   Use a tool like `electron-forge` or `electron-builder` to package your application for distribution.  `electron-forge` is shown in the example `package.json` in [Build an Electron app using Vite, TypeScript and React](mdc:https:/medium.com/@selfint/build-an-electron-app-using-vite-typescript-and-react-e98f7fc1babd).
    *   Configure your packaging tool to include the necessary files from the `dist` directory.

3.  **Code Signing:**

    *   Code sign your application for production builds, especially on macOS and Windows. This is crucial for security and user trust.

## Security Considerations

*   **Context Isolation:** Enable context isolation (`contextIsolation: true` in `webPreferences`). This is a critical security feature that prevents the renderer process from directly accessing Node.js APIs.
*   **Sandboxing:** Consider enabling sandboxing for an additional layer of security.  [alexwkleung/Electron-ESM-Vite](mdc:https:/github.com/alexwkleung/Electron-ESM-Vite) mentions using an unsandboxed renderer with context isolation for ESM preload scripts.  Carefully evaluate the security implications of this approach.  If possible, use a sandboxed renderer.
*   **Preload Scripts:** Use preload scripts to expose only the necessary APIs to the renderer process. Avoid exposing unnecessary functionality.
*   **Content Security Policy (CSP):** Implement a strong CSP to mitigate the risk of cross-site scripting (XSS) attacks.
*   **Remote Content:** Be extremely cautious when loading remote content.  If possible, avoid loading remote content entirely.  If you must load remote content, use a `webview` tag and carefully validate the content.
*   **Regular Updates:** Keep Electron and your dependencies up to date to patch security vulnerabilities.

## Advanced Topics

*   **Source Code Protection:**  `electron-vite` supports using V8 bytecode to protect your source code ([electron-vite.org/guide/](mdc:https:/electron-vite.org/guide)).
*   **Native Modules:** If you need to use native Node.js modules, you'll need to configure Vite to handle them correctly. This often involves using the `native_modules` configuration option in `electron-vite`.
*   **Multiple Windows:**  For applications with multiple windows, manage the creation and communication of these windows in the main process.  Each window will have its own renderer process.

## Conclusion

By following these best practices, you can create robust, secure, and maintainable Electron applications using Vite and TypeScript. The combination of Vite's speed, TypeScript's type safety, and Electron's cross-platform capabilities provides a powerful foundation for building modern desktop applications. Remember to prioritize security and follow Electron's security recommendations throughout the development process.